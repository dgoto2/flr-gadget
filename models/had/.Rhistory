abline(h=0)
resids <- residuals(kem.1)
plot(resids$model.residuals[1,], ylab="model residual", xlab="", main="linear trend")
abline(h=0)
plot(resids$state.residuals[1,], ylab="state residual", xlab="", main="linear trend", ylim=c(-1,1))
abline(h=0)
resids <- residuals(kem.2)
plot(resids$model.residuals[1,], ylab="model residual", xlab="", main="stoc level")
abline(h=0)
plot(resids$state.residuals[1,], ylab="state residual", xlab="", main="stoc level")
abline(h=0)
## ----uss-acf0, fig.show='hide'------------------------------------------------------------------------------------
par(mfrow=c(2,2))
resids <- residuals(kem.0)
acf(resids$model.residuals[1,], main="flat level v(t)", na.action=na.pass)
resids <- residuals(kem.1)
acf(resids$model.residuals[1,], main="linear trend v(t)", na.action=na.pass)
resids <- residuals(kem.2)
acf(resids$model.residuals[1,], main="stoc level v(t)", na.action=na.pass)
acf(resids$state.residuals[1,], main="stoc level w(t)", na.action=na.pass)
## ----uss-acfs, echo=FALSE, fig=TRUE, fig.cap='(ref:uss-acfs)'-----------------------------------------------------
par(mfrow=c(2,2))
resids <- residuals(kem.0)
acf(resids$model.residuals[1,], main="flat level v(t)", na.action=na.pass)
resids <- residuals(kem.1)
acf(resids$model.residuals[1,], main="linear trend v(t)", na.action=na.pass)
resids <- residuals(kem.2)
acf(resids$model.residuals[1,], main="stoc level v(t)", na.action=na.pass)
acf(resids$state.residuals[1,], main="stoc level w(t)", na.action=na.pass)
## ----uss-jags-data------------------------------------------------------------------------------------------------
library(datasets)
y <- as.vector(Nile)
## ----uss-loadpackages-jags, results='hide', message=FALSE, warning=FALSE------------------------------------------
library(R2jags)
library(rjags)
library(coda)
## ----uss-loadpackages-jags, results='hide', message=FALSE, warning=FALSE------------------------------------------
library(R2jags)
library(rjags)
library(coda)
## ----uss-jags-model-----------------------------------------------------------------------------------------------
model.loc <- "ss_model.txt"
jagsscript <- cat("
model {
# priors on parameters
mu ~ dnorm(Y1, 1/(Y1*100)); # normal mean = 0, sd = 1/sqrt(0.01)
tau.q ~ dgamma(0.001,0.001); # This is inverse gamma
sd.q <- 1/sqrt(tau.q); # sd is treated as derived parameter
tau.r ~ dgamma(0.001,0.001); # This is inverse gamma
sd.r <- 1/sqrt(tau.r); # sd is treated as derived parameter
u ~ dnorm(0, 0.01);
# Because init X is specified at t=0
X0 <- mu
X[1] ~ dnorm(X0+u,tau.q);
Y[1] ~ dnorm(X[1], tau.r);
for(i in 2:TT) {
predX[i] <- X[i-1]+u;
X[i] ~ dnorm(predX[i],tau.q); # Process variation
Y[i] ~ dnorm(X[i], tau.r); # Observation variation
}
}
",file=model.loc)
## ----uss-jags-set-------------------------------------------------------------------------------------------------
jags.data <- list("Y"=y, "TT"=length(y), Y1=y[1])
jags.params <- c("sd.q", "sd.r", "X", "mu", "u")
## ----uss-jags-fit, results='hide', message=FALSE, cache=TRUE------------------------------------------------------
mod_ss <- jags(jags.data, parameters.to.save=jags.params,
model.file=model.loc, n.chains = 3,
n.burnin=5000, n.thin=1, n.iter=10000, DIC=TRUE)
## ----uss-fig-posteriors, fig=TRUE, fig.cap='(ref:uss-fig-posteriors)', message=FALSE, cache=TRUE------------------
attach.jags(mod_ss)
par(mfrow=c(2,2))
hist(mu)
abline(v=coef(kem.3)$x0, col="red")
hist(u)
abline(v=coef(kem.3)$U, col="red")
hist(log(sd.q^2))
abline(v=log(coef(kem.3)$Q), col="red")
hist(log(sd.r^2))
abline(v=log(coef(kem.3)$R), col="red")
detach.jags()
## ----uss-jags-plot-states-fun, message=FALSE, warning=FALSE-------------------------------------------------------
plotModelOutput <- function(jagsmodel, Y) {
attach.jags(jagsmodel)
x <- seq(1,length(Y))
XPred <- cbind(apply(X,2,quantile,0.025), apply(X,2,mean), apply(X,2,quantile,0.975))
ylims <- c(min(c(Y,XPred), na.rm=TRUE), max(c(Y,XPred), na.rm=TRUE))
plot(Y, col="white",ylim=ylims, xlab="",ylab="State predictions")
polygon(c(x,rev(x)), c(XPred[,1], rev(XPred[,3])), col="grey70",border=NA)
lines(XPred[,2])
points(Y)
}
## ----uss-fig-bayesian-states, echo=TRUE, fig=TRUE, fig.cap='(ref:uss-fig-bayesian-states)', cache=TRUE------------
plotModelOutput(mod_ss, y)
lines(kem.3$states[1,], col="red")
lines(1.96*kem.3$states.se[1,]+kem.3$states[1,], col="red", lty=2)
lines(-1.96*kem.3$states.se[1,]+kem.3$states[1,], col="red", lty=2)
title("State estimate and data from\nJAGS (black) versus MARSS (red)")
## ----uss-stan-setup, message=FALSE--------------------------------------------------------------------------------
library(datasets)
library(rstan)
y <- as.vector(Nile)
## ----uss-stan-ar-model--------------------------------------------------------------------------------------------
scode <- "
data {
int<lower=0> TT;
int<lower=0> n_pos; // number of non-NA values
int<lower=0> indx_pos[n_pos]; // index of the non-NA values
vector[n_pos] y;
}
parameters {
real x0;
real u;
vector[TT] pro_dev;
real<lower=0> sd_q;
real<lower=0> sd_r;
}
transformed parameters {
vector[TT] x;
x[1] = x0 + u + pro_dev[1];
for(i in 2:TT) {
x[i] = x[i-1] + u + pro_dev[i];
}
}
model {
x0 ~ normal(y[1],10);
u ~ normal(0,2);
sd_q ~ cauchy(0,5);
sd_r ~ cauchy(0,5);
pro_dev ~ normal(0, sd_q);
for(i in 1:n_pos){
y[i] ~ normal(x[indx_pos[i]], sd_r);
}
}
generated quantities {
vector[n_pos] log_lik;
for (i in 1:n_pos) log_lik[i] = normal_lpdf(y[i] | x[indx_pos[i]], sd_r);
}
"
## ----uss-stan-fit-model, message=FALSE, warning=FALSE, results='hide', cache=TRUE---------------------------------
# We pass in the non-NA ys as vector
ypos <- y[!is.na(y)]
n_pos <- sum(!is.na(y)) #number on non-NA ys
indx_pos <- which(!is.na(y)) #index on the non-NAs
mod <- rstan::stan(model_code = scode,
data = list("y"=ypos, "TT"=length(y), "n_pos"=n_pos, "indx_pos"=indx_pos),
pars = c("sd_q","x", "sd_r", "u", "x0"),
chains = 3, iter = 1000, thin = 1)
## ----uss-stan-ar-level, fig.cap="Estimated level and 95 percent credible intervals.  Blue dots are the actual Nile River levels."----
pars <- rstan::extract(mod)
pred_mean <- apply(pars$x, 2, mean)
pred_lo <- apply(pars$x, 2, quantile, 0.025)
pred_hi <- apply(pars$x, 2, quantile, 0.975)
plot(pred_mean, type = "l", lwd = 3,
ylim = range(c(pred_mean, pred_lo, pred_hi)), ylab = "Nile River Level")
lines(pred_lo)
lines(pred_hi)
points(y, col="blue")
## ----uss-stan-ar-level-ggplot, fig.cap="Estimated level and 95 percent credible intervals"------------------------
library(ggplot2)
nile <- data.frame(y=y, year=1871:1970)
h <- ggplot(nile, aes(year))
h + geom_ribbon(aes(ymin = pred_lo, ymax = pred_hi), fill = "grey70") +
geom_line(aes(y = pred_mean), size=1) +
geom_point(aes(y = y), color="blue") +
labs(y = "Nile River level")
## ----uss-stan-hist-pars, fig.cap="Histogram of the parameter samples versus the estimate (red line) from maximum likelihood."----
par(mfrow = c(2, 2))
hist(pars$x0)
abline(v = coef(kem.3)$x0, col = "red")
hist(pars$u)
abline(v = coef(kem.3)$U, col = "red")
hist(log(pars$sd_q^2))
abline(v = log(coef(kem.3)$Q), col = "red")
hist(log(pars$sd_r^2))
abline(v = log(coef(kem.3)$R), col = "red")
base1000 <- readRDS("C:/Users/daisu/Dropbox/WK_WKN~1.3A4/output/runs/pok/1000_21/TEST_U~1/TEST_U~4/HC7175~1.RDS")
install.packages(c("ade4", "Deriv", "generics", "googlePolylines", "graphlayouts", "KernSmooth", "officer", "openxlsx", "quantreg", "R6", "segmented", "sfheaders", "testthat", "tinytex", "V8", "xfun"))
## post-prossessing of mohn's rho for ns saithe mse simulations
library(icesAdvice)
library(ggsci)
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
library(ggpubr)
library(Hmisc)
library(cowplot)
## historical mohn's rho for ns saithe
saithe<-read.table(file="/Users/daisu/Dropbox/wk_WKNSMSE_pok.27.3a46/mohn_saithe.csv", header = T, sep = ",")
colnames(saithe) <- c("year", "metric", "base", "-1", "-2", "-3", "-4", "-5")
## fbar
saitheF <- saithe %>% filter(metric=="fbar") %>% select(-c("year", "metric"))
rownames(saitheF) <- c("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018")
mohn(saitheF, details = T, plot = T)
mohn(saitheF, peels=5, plot=TRUE, col="black", yaxs="i")
lines(as.numeric(rownames(saitheF)), saitheF$base, lwd=3)
## ssb
saitheSSB <- saithe %>% filter(metric=="ssb") %>% select(-c("year", "metric"))
rownames(saitheSSB) <- c("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018")
mohn(saitheSSB, details = T, plot = T)
mohn(saitheSSB, peels=5, plot=TRUE, col="black", yaxs="i")
lines(as.numeric(rownames(saitheSSB)), saitheSSB$base, lwd=3)
saithe_ssb_plot <- saithe %>% filter(metric=="ssb")
saithe_ssb_plot
saithe_ssb_plot <- saithe %>% filter(metric=="ssb")
colnames(saithe_ssb_plot) <- c("year", "metric", "2018", "2017", "2016", "2015", "2014", "2013", "2012")
saithe_ssb_plot_long <- gather(saithe_ssb_plot, assess.year, value,  "2018":"2012", factor_key=T)
saithe_ssb_plot
saithe_ssb_plot <- saithe %>% filter(metric=="ssb")
colnames(saithe_ssb_plot) <- c("year", "metric", "2018", "2017", "2016", "2015", "2014", "2013")
saithe_ssb_plot_long <- gather(saithe_ssb_plot, assess.year, value,  "2018":"2013", factor_key=T)
library(directlabels)
library(ggthemes)
plot_ssb <- ggplot(saithe_ssb_plot_long, aes(year, value, group=assess.year)) +
scale_fill_jco() + scale_color_jco() +
#scale_color_stata(scheme = "s2color") +
geom_line(aes(col=assess.year), size=2) + #size=0.5
#geom_point(aes(col=assess.year), size=5) + # obs data
geom_hline(yintercept=c(107000), linetype="dashed", color = "red", size=0.5) +
xlab("Year") +
ylab("Spawner abundance (t)") +
#theme_bw() +
theme_stata() +
theme(#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(colour = "white"),
#element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "black"),
axis.title.x = element_text(size=20),
axis.title.y = element_text(size=20),
axis.text.x = element_text(size=13),
axis.text.y =element_text(size=13)) +
theme(legend.background = element_blank()) +
theme(legend.position="none") +
theme(legend.title = element_blank()) +
theme(legend.text = element_text(colour="black", size = 14),
legend.spacing.x = unit(0.1, 'cm'),
legend.key.width =  unit(1, 'cm')) +
theme(plot.title = element_text(hjust = 0.5)) +
#guides(colour=guide_legend(ncol=3, nrow=1, byrow=TRUE, override.aes = list(size = 2))) + ## set N of col for legends
#stat_smooth(size = 1.5, color = "red", alpha = 0.5, fill = "gray")
theme(legend.key = element_blank()) +
#theme(legend.position = "top") +
geom_dl(aes(label = assess.year, color=assess.year), method = list(dl.combine("last.points"), cex = 2, face = "bold"))
plot_ssb
## output resolution 1000 x 800 for 3 col; 700 x800  for 2col; 400x800
Blim <- 107297
library(directlabels)
library(ggthemes)
plot_ssb <- ggplot(saithe_ssb_plot_long, aes(year, value, group=assess.year)) +
scale_fill_jco() + scale_color_jco() +
#scale_color_stata(scheme = "s2color") +
geom_line(aes(col=assess.year), size=2) + #size=0.5
#geom_point(aes(col=assess.year), size=5) + # obs data
geom_hline(yintercept=c(Blim), linetype="dashed", color = "red", size=0.5) +
xlab("Year") +
ylab("Spawner abundance (t)") +
#theme_bw() +
theme_stata() +
theme(#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(colour = "white"),
#element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "black"),
axis.title.x = element_text(size=20),
axis.title.y = element_text(size=20),
axis.text.x = element_text(size=13),
axis.text.y =element_text(size=13)) +
theme(legend.background = element_blank()) +
theme(legend.position="none") +
theme(legend.title = element_blank()) +
theme(legend.text = element_text(colour="black", size = 14),
legend.spacing.x = unit(0.1, 'cm'),
legend.key.width =  unit(1, 'cm')) +
theme(plot.title = element_text(hjust = 0.5)) +
#guides(colour=guide_legend(ncol=3, nrow=1, byrow=TRUE, override.aes = list(size = 2))) + ## set N of col for legends
#stat_smooth(size = 1.5, color = "red", alpha = 0.5, fill = "gray")
theme(legend.key = element_blank()) +
#theme(legend.position = "top") +
geom_dl(aes(label = assess.year, color=assess.year), method = list(dl.combine("last.points"), cex = 2, face = "bold"))
plot_ssb
## output resolution 1000 x 800 for 3 col; 700 x800  for 2col; 400x800
if (HCRoption %in% 2) {
input$ctrl.mp$ctrl.is@args$TAC_constraint <- TRUE
}
HCRoption =2
if (HCRoption %in% 2) {
input$ctrl.mp$ctrl.is@args$TAC_constraint <- TRUE
}
paste0(getwd(), "/")
dirname(rstudioapi::getActiveDocumentContext()$path)#pas
setwd("C:/Users/daisu/Dropbox/git/flr-gadget")
# Install required packages (if not already)
remotes::install_github("REDUS-IMR/gadget", ref = "gadgetr")
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS="TRUE")
remotes::install_github("flr/mse")
# Load packages
library(mse)
library(dplyr)
library(FLa4a)
library(FLash)
library(FLAssess)
library(ggplotFL)
library(FLBRP)
library(FLCore)
library(MASS)
library(FLSAM)
library(filelock)
#library(profvis) # Performance measurement
#=====================================================================
# Set up an MSE loop
#=====================================================================
runOneTimeline <- function(iterSim, saveRaw) {
# Set seed
set.seed(0)
# Create directories for the Gadget OM and helper functions
codeDir <- paste0(homeDir, "codes")
paramFileDir <- paste0(homeDir, "paramfiles")
# Load GadgetR locally
library(gadgetr)
# Load helper functions
source(paste0(codeDir, "/gadget-fls.R"), local = T)
source(paste0(codeDir, "/assessment.R"), local = T)
# Load the stock and files
# Set a directory for the Gadget OM
setwd(paste0(homeDir, "/models/", modelName))
# Load Gadget parameters
paramsfile <- "refinputfile"
gadget(c("-s", "-main", "main", "-i", paramsfile))
# Initialize simulation
initSim()
# Set simulation time parameters
firstYear <- 1978
projYear <- 2000
finalYear <- 2020
# Set up a stock (or stocks) for Gadget
stockList <- c("had")
had.fleets <- c("comm", "survey", "future")
had.stocks <- c("had")
had.stocks.mature <- c("had")
had.surveys <- c("survey")
had.forecasts <- c("future")
# Set stock parameters for the OM
had.params <- list(stockStep = 2, minage = 1, maxage = 10, minfbar = 2, maxfbar = 8,
startf = 0.56, endf = 0.65, areas = c(1), m1 = c(0.2), m2 = NULL)
# m2 = NULL means we calculate m2 from gadget result, m2=0 means we use only residual mortality (m1)
# StockStep: in which step we should observe the stock number
# Set quarterly allocation of TAC
had.forecasts.tac.proportion <- c(0.232, 0.351, 0.298, 0.119)
# Set HCR function parameters (in this example, ICES HCR)
had.hcr.params <- list(method = ices.hcr, args = list(blim = 100000, bsafe = 200000, fmin = 0.05, ftrg = 0.25))
# Set recruitment parameters
# If read csv (as a data frame), it will apply the values accordingly
# If a constant value, it will apply the value as mux
# If NULL, it will leave the recruitment params as it is
#had.recruit.params <- read.csv(paste0(paramFileDir, "/muxfactors_cod.csv"))
had.recruit.params <- 90000000 # constant recruit number
#had.recruit.params <- NULL ## recruit params
# Set assessment model parameters (truePlusNoise, SCAA/a4a, or SAM)
# Select an assessment model
had.assessment <- "SAM" ## "truePlusNoise", "SCAA" or "SAM"
# If truePlusNoise is chosen, the noise using the residual params will be applied to stock only
# Set noise parameters
noise_age <- data.frame(age = c (1:10), mean = array(0.001283, dim = c(10,1)), sd = array(0.053986, dim = c(10,1))) # generate simple noise
had.residual.params.catch <- noise_age
had.residual.params.stock <- noise_age
# If SCAA is chosen, the noise will be applied to both catch and index
had.residual.params.index <- noise_age
# If no error is applied
had.residual.params.mean.stock <- NULL
had.residual.params.vcratios.stock <- NULL
#had.residual.params <- NULL
had.noteating.forecast <- FALSE
# Set Gadget output
gadgetOut <- list()
# performance measurements
#test <- profvis({
# Run Gadget until the projection year - 1 for conditioning the OM
gadgetOut <- runUntil(projYear - 1)
#})
#print(test)
#browser()
# Set up a projection loop
prepareStock  <- function(stockNameGl) {
#------------------------------------------------------------------------------
# OM object
#------------------------------------------------------------------------------
# Use Gadget output to condition the OM
gadget.ret <- gadgetOut[[stockNameGl]]
stk <- gadget.ret$stk
idx <- FLIndices(a = gadget.ret$idx)
# Set MSE simualtion parameters
it <- 1                     # iterations
fy <- finalYear             # final year
y0 <- range(stk)["minyear"] # initial data year
dy <- range(stk)["maxyear"] # final data year
iy <- projYear              # initial year of projection (also intermediate)
ny <- fy - iy + 1           # number of years to project from intial year
nsqy <- 3                   # number of years to compute status quo metrics
vy <- ac(iy:fy)             # vector of years to be projected
management_lag <- 1         # For ICES HCR
# Use short-term forecasts to create an initial stock object
stk <- stf(stk, fy-dy, nsqy, nsqy)
# Set fleet parameters
#fb <- mseCtrl(method = hyperstability.fb, args = list(beta = 0.8))
# Create an OM object
om <- FLom(stock = stk)#, fleetBehaviour = fb)
#save(om, it, fy, y0, dy, iy, ny, nsqy, vy, fit, file = "om.RData")
#-----------------------------------------------------------------------------
# OEM object
#-----------------------------------------------------------------------------
# Set survey indices
idx <- FLIndices(a = gadget.ret$idx)
stk <- stock(om)
stk0 <- stk
idcs <- FLIndices()		# Use all indices
for (i in 1:length(idx)){
# Estimate survey catchability from the a4a fit (w/o simulation)
# the index is based on 01 January abundances
lst <- mcf(list(idx[[i]]@index, stock.n(stk0)))
idx.lq <- log(lst[[1]]/lst[[2]])
idx.qmu <- idx.qsig <- stock.n(iter(stk, 1)) ## set a data frame for indices
idx.qmu[] <- yearMeans(idx.lq) ## use constant catchability
idx.qsig[] <- sqrt(yearVars(idx.lq))
idx.q <- FLQuant(NA, dimnames = dimnames(stock.n(stk)))
# Estimate survey catchability based on lognormal distribution with mean and sd calculated above
idx.q <- rlnorm(it, idx.qmu, idx.qsig)
#idx.q[, ac(y0:iy)] <- idx.q[,ac(y0:iy)]
idx_temp <- idx.q * stock.n(stk)
## Generate an initial index
idx_temp <- FLIndex(index = idx_temp, index.q = idx.q)
range(idx_temp)[c("startf", "endf")] <- c(0, 0)
idcs[[i]] <- idx_temp
}
names(idcs) <- names(idx)
#idx <- FLIndices(a=idcs$a)
idxDev <- lapply(idcs, index.q)
names(idxDev) <- "index.q"
stkDev <- FLQuant()
dev <- list(idx = idxDev, stk = stkDev)
obs <- list(idx = idcs[1], stk = stk)
## Set deviances for catch.n
#catch.dev <- log(catch.n(stk))
#catch.dev <- catch.dev-iterMeans(catch.dev)
#Sig <- apply(catch.dev[,ac(y0:dy),1,1,,drop=TRUE], 3, function(x) cov(t(x)))
#Sig <- apply(Sig, 1, mean)
#Sig <- matrix(Sig, ncol=dim(catch.dev)[1])
#catch.dev[,ac(vy)][] <- t(mvrnorm(it * length(vy), rep(0, nrow(Sig)), Sig))
#catch.dev <- exp(catch.dev)
# Create an OEM object
#oem <- FLoem(method = sampling.oem, args = list(oe = "index"), observations = obs, deviances = dev)
oem <- FLoem()
#save(oem, file = "oem.RData")
# Set implementation error parameters
#iem <- FLiem(method=noise.iem, args=list(fun="rlnorm", mean=0, sd=0.1, multiplicative=TRUE))
iem <- FLiem()
#-----------------------------------------------------------------------
# Management procedure (MP) object
#-----------------------------------------------------------------------
# Set MP parameters
mpPars <- list(seed = 1234, fy = fy, y0 = y0, dy = dy, iy = iy, management_lag = management_lag, nsqy = nsqy, it = it)
# Set simulation scenarios
# Set a consumption rule for predatory stocks to stop eating (if requested) only applied to multispecies models
if(eval(parse(text=paste0(stockNameGl, ".noteating.forecast")))){
stockCat <- eval(parse(text = paste0(stockNameGl, ".stocks")))
tmp <- lapply(stockCat, stopEating)
print("Stocks stop eating now")
print(tmp)
}
## Set stock-specific HCR parameters
hcrParams <- eval(parse(text=paste0(stockNameGl, ".hcr.params")))
## Set assessment model parameters
saParam <- eval(parse(text = paste0(stockNameGl, ".assessment")))
if(saParam == "truePlusNoise") saMethod <- truePlusNoise.sa
else if(saParam == "SCAA") saMethod <- sca.sa
else if(saParam == "SAM") saMethod <- sam.sa
# Set MP object parameters
ctrl <- list(hcr = mseCtrl(method = hcrParams[["method"]], args = hcrParams[["args"]]),
isys = mseCtrl(method = tac.is), est = mseCtrl(method = saMethod))
# Set scenario names
scenarioName <- paste0(stockNameGl, ".", "iter", iterSim)
return(list(opModel = om, indices = idx, obsModel = oem, impModel = NULL, ctrl.mp = ctrl,
mpPars = mpPars, scenario = scenarioName, tracking = NULL))
}
# Load helper functions
source(paste0(codeDir, "/gadget-fwd.R"), local = T)
source(paste0(codeDir, "/mp-methods-gadget.R"), local = T)
# Apply mp to compute TAC and peformance metrics
inputPre <- lapply(stockList, prepareStock)
names(inputPre) <- stockList
res <- mp.gadget(inputPre)
#return(list(mseResults = res, gadgetResults = gadgetOut))
return(list(mseResults = res))
}
#======================================================================
# Run MSE simulations
#======================================================================
# Enable below to run directly from R shell
combIndex <- 1
iterIndex <- 1
# Set global variables
homeDir <- paste0(getwd(), "/")
modelName <- "had"
saveAllRawData <- FALSE
homeDir
# Read effort combination
#print(paste("combination no.", combIndex, "iteration", iterIndex))
#fComb <- read.csv(paste0(homeDir, "paramfiles/effort_combination.csv"))
# Run with combination and iterIndex
resultFinal <- runOneTimeline(iterIndex, saveAllRawData)
